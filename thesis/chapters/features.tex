\chapter{Features}

This chapter tries to itentify features provided by mature language workbenches and general purpose languages to build domain-specific languages.

\section{Language Workbench Features}


\subsection{MPS}

\subsection{Rascal}

\subsection{Spoofax}

\citeauthor{kats2010spoofax} describe Spoofax as a Language Workbench for efficient, agile development of software languages with state-of-the-art IDE support \cite{kats2010spoofax}.
Spoofax uses several metalanguages for specific tasks. 

\subsubsection{SDF3}

SDF3 

\section{eDSL Features}

\subsection{Haskell}

Template Haskell is an language extension for Haskell 98 orignally designed by \citeauthor{sheard2002template} for the Glasgow Haskell Compiler which provides type-safe compile-time meta-programming facilties \cite{sheard2002template}.

The following noticeable features are provided by Template Haskell.

\subsubsection{Quotation}

Quotation transforms Haskell concrete syntax to Haskell AST at compile time.
Template Haskell provides quotation for:
\begin{itemize}
	\item expressions
	\item top-level declarations
	\item types
	\item and patterns.
\end{itemize}

Listing \ref{lst:haskell/QuotedExp/source} shows quotation of the expression \lstinline{(1 [2, 3])} and its resulting AST representation in Figure \ref{fig:haskell/QuotedExp/ast}.

\lstinputlisting[caption={Template Haskell quoted expression}, label={lst:haskell/QuotedExp/source}, language=Haskell]{haskell/QuotedExp.hs}
\begin{figure}[h]
	\centering
	\begin{forest}
		[TupE 
			[LitE 
				[IntegerL 
					[1]
				]
			]
			[ListE 
				[LitE 
					[IntegerL 
						[2]
					]
				]
				[LitE
					[IntegerL 
						[3]
					]
				]
			]
		]
	\end{forest}
	\caption{Template Haskell AST \label{fig:haskell/QuotedExp/ast}}
\end{figure}

\subsubsection{Quasi-Quotation}

Quasi-Quotation in Template Haskell works much like Quotation does.
Instead of Haskell concrete syntax the quasi-quoter takes an arbitrary string.

\subsubsection{Splicing}

Splicing transforms a Haskell AST to concrete syntax at compile time.
The spliced AST must represent either a
\begin{itemize}
	\item expression
	\item pattern
	\item type
	\item or a list of declerations.
\end{itemize}

Listing \ref{lst:haskell/SplicedExp/source} shows splicing of the quoted expression shown in Listing \ref{lst:haskell/QuotedExp/source} back to the concrete syntax representation.
The spliced expression results in the corresponding Haskell source code \lstinline{(1 [2, 3])}.
\lstinputlisting[caption={Template Haskell Spliced Expression}, label={lst:haskell/SplicedExp/source}, language=Haskell]{haskell/SplicedExp.hs}


\subsubsection{Limitations}

GHC stage restriction

\subsection{Racket}

Racket reader lang

\subsection{Scala}

Scala Macros

\section{Feature Model}


